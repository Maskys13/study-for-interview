### 1.const定义一个对象，能用另一个对象替换？
```
不能，const声明一个只读常量，一旦声明，常量的值就不能改变。
```
### 2.JS内存泄漏有哪些情况？
```
1. 循环引用：当两个或多个对象之间存在相互引用，并且没有被其他对象引用，就会发生循环引用，从而导致内存泄漏。这种情况可以通过在对象之间断开引用来避免。
2. 定时器未清除：在JavaScript中使用setInterval和setTimeout函数时，必须确保在不需要他们时清除这些定时器。
3. DOM元素未正确删除：在使用JS操作DOM元素时，必须确保在不需要它们时正确删除它们。
4. 全部变量未清除：在JS中，如果定义了全局变量，它们将一直存在于内存中，直到页面关闭。如果不需要全局变量，请确保在使用后将其删除或赋值为null。
5. 闭包未正确使用：在JS中，闭包可以让函数访问其定义时的作用域，但如果未正确使用闭包，也可能导致内存泄漏。在使用闭包时，请确保只保留必要的引用，并在不需要时删除它们。
6. 事件未及时解绑：在JS中，如果注册了事件监听器却没有及时解绑，就会导致内存泄漏。例如当一个元素被删除时，它仍然保留对事件监听器的引用，如果没有解绑，事件监听器将无法被垃圾回收。
```
### 3.闭包为什么会造成内存泄漏？
```
闭包：1.父函数嵌套子函数，子函数访问父函数的局部变量。2.通过return返回这个子函数，暴露到全部作用域中，子函数形成了闭包。3.通过闭包，父函数的局部变量没有被销毁，可通过闭包去调用，但同时，这个局部变量也不会被全局变量污染。
闭包的作用与优缺点：
作用：
1）保护：保护函数的私有变量不被外部干扰。
2）保存：把一些函数内的值保存下来，闭包可以实现方法与属性的私有化。

优点：
1）延长局部变量的生命周期。
2）避免全局污染。
3）函数外部能访问函数内容的变量。

缺点：
1）闭包会携带包含其他的函数作用域，因此会比其他函数占用更多的内存。
2）不正当的使用可能会造成内存泄漏。

1. 难以控制：闭包能够访问外部函数的作用域，这意味着外部函数的变量可能会被闭包内部修改。如果这些变量不被正确处理，可能会导致内存泄漏。
2. 占用内存：闭包内部访问的变量通常不会被回收机制释放，因为它们被保存在了闭包的执行环境中。全局变量由于随时可以被任何程序在任何地方读写，所以回收机制很难统计何时需要释放全局变量所占用的内存，也就导致全局变量一般在全局执行环境被销毁时才会释放。闭包由于能够访问外部函数的变量，如果这些变量是引用类型（如Array、Object、Function），它们的值存储在堆内存中，而闭包的执行环境（栈内存）会引用这些变量，导致它们不会被回收机制释放，从而形成内存泄漏。
闭包本身不会直接造成内存泄漏，但如果在代码中过度使用闭包，并且没有正确处理闭包内部访问的变量，就可能存在内存泄漏的风险。
```
### 4.JS的数据类型
```
简单数据类型：string、number、boolean、null、undefined、symbol、bigInt
复杂数据类型：object(function、array。。。)
```
### 5.typeof和instanceof的区别
```
typeof能识别简单数据类型及函数，对于array和object无法区分，其中null 的检测值也为 object
instanceof用于检测构造函数的prototype是否出现在某个实例的原型链上，可以区分引用数据类型
```
### 6.实现一个类似关键字new功能的函数
```javascript
// new关键字：先创建一个空对象，将对象的__proto__指向构造函数的原型对象，然后将构造函数的this指向这个空对象，并执行构造函数的逻辑，根据构造函数的执行逻辑，返回初始创建的对象或构造函数的显式返回值。
function newFunc(...args) {
  const constructor = args.shift()
  const newInstance = Object.create(constructor.prototype)
  const res = constructor.apply(newInstance, args)
  return (typeof res === 'object' || typeof res === 'function') && res !== null ? res : newInstance
}
```
### 7.继承
```
1.原型链继承
  优点：
      1.父类方法可以复用
  缺点：
      1.父类的所有引用属性（info）会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响
      2.子类型实例不能给父类型构造函数传参

2.借用构造函数继承
  优点:
      1.可以在子类构造函数中向父类传参数
      2.父类的引用属性不会被共享
  缺点：
      1.子类不能访问父类原型上定义的方法（即不能访问Parent.prototype上定义的方法），因此所有方法属性都写在构造函数中，每次创建实例都会初始化

3.组合继承
  优点：
      1.父类的方法可以复用
      2.可以在Child构造函数中向Parent构造函数中传参
      3.父类构造函数中的引用属性不会被共享

4.原型式继承
  优点：
      1.父类方法可复用
  缺点：
      1.父类的引用会被所有子类所共享
      2.子类实例不能向父类传参

5.寄生式继承
  优点：写法简单，不需要单独创建构造函数。
  缺点：通过寄生式继承给对象添加函数会导致函数难以重用。使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率;这一点与构造函数模式类似.

6.寄生式组合继承
  优点：
      1.只调用一次父类构造函数
      2.Child可以向Parent传参
      3.父类方法可以复用
      4.父类的引用属性不会被共享

7.ES6类继承
```
### 8.箭头函数和普通函数的区别
```
1. 箭头函数没有自己的this,它的this就是外部作用域的this.
2. 箭头函数不能作为构造函数，没有prototype.
3. 箭头函数没有arguments对象，可以用rest代替
4. 箭头函数不能用yield命令，不能用作generator函数
```
### 9.迭代器(iterator)接口和生成器(generator)函数的关系
```
iterator遍历器是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作。
Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。
ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要有Symbol.iterator属性，就可以认为是可遍历的。Symbol.iterator本身是一个函数，默认的遍历器生成函数。执行这个函数就会返回一个遍历器
generator函数是一种异步编程解决方案，它就像一个状态机，封装了多个内部状态。执行generator函数会返回一个iterator对象，generator函数是一个状态机，也是遍历器生成函数。返回的遍历器对象可以依次遍历函数内部的每一个状态。
```
### 10.浏览器的事件循环机制
<img src='../images/eventloop.png'>

### 11.跨域
```
由于浏览器的同源策略（浏览器安全功能，它会阻止一个域与另一个域的内容进行交互，能有效防止XSS、CSRF攻击）的限制、非同源的请求会被限制。协议、域名、端口号
解决跨域：
    1. jsonp
    2. nginx反向代理
    3. iframe
    4. WebSocket
    5. 设置cors
```
### 12.浏览器的存储有哪些及区别
```
1. cookie: 有时效性，存储小4KB左右，http请求会携带
2. localStorage: 无时效性，除非手动保存，永久保存，存储大5MB左右
3. sessionStorage：关闭页面或浏览器会清除
4. indexDB
```
### 13.loader和plugin的区别
```
loader: 由于webpack只能打包commonjs规范的文件，因此针对css、图片等格式的文件没法打包，就需要引入第三方模块就行打包。loader扩展了webpack,只专注于文件转换，完成压缩，打包，翻译，仅仅只是为了打包。
plugin: plugin也是为了扩展webpack的功能，但是plugin是作用于webpack本身的。不局限于打包，资源加载上，解决loader无法实现的其他事。在整个编译周期起作用，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过Webpack提供的 API 改变输出结果。
```
### 14.深浅拷贝
```
浅拷贝将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用（拷贝后的引用都是指向同一个对象的实例，彼此之间的操作会互相影响）

深拷贝是将原对象的各个属性的“值”逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深拷贝的方法递归复制到新对象上（注意拷贝的“值”而不是“引用”）

深拷贝的方式：
    1.JSON.parse(JSON.stringify()), function和undefined无法拷贝
    2.递归
    3.jquery的$.extend(true, {}, obj)
    4.只有一层时，Object.assign({}, obj)
    5.只有一层时，扩展运算符(...)
```
### 15.防抖和节流
```
防抖(debounce): 当一个事件连续被触发时，防抖技术将只执行最后一次触发事件的函数调用。(n秒之后才触发函数调用，n秒内如果被连续触发，则重新计时)
使用防抖的场景： - 搜索框输入联想：用户在输入时，如果一直输入，会频繁触发搜索请求，使用防抖可以减少请求的次数，只在用户停止输入后才发送请求。 - 页面滚动加载更多：当用户滚动页面时，会频繁触发加载更多数据的函数，使用防抖可以减少请求的次数，只在用户停止滚动后才发送请求。

节流(throttle): 当一个事件被连续触发时，节流技术会限制函数的执行频率，函数在一段时间内只会执行一次。(n秒内只运行一次，若在n秒内重复触发，只有一次生效)
使用节流的场景： - 页面滚动事件：当用户滚动页面时，会触发滚动事件，如果不使用节流技术，可能会导致页面卡顿。使用节流可以限制滚动事件的触发频率，减少卡顿现象。
```
### 16.首屏加载如何优化
```
1.减小入口文件的体积
2.静态资源本地缓存
3.UI框架按需加载
4.图片资源的压缩
5.组件重复打包
6.开启Gzip压缩
7.使用ssr
```
### 17.作用域和作用域链
```
作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。
​
作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。
​
当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。
​
作用域链的创建过程跟执行上下文的建立有关
```
### 18.js延迟加载的方式
```
js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。
​
1.  将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。
2.  给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。
3.  给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。
4.  动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。
```
### 19.js的几种模块规范
```
js 中现在比较成熟的有四种模块加载方案：
​
*   第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。
*   第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。
*   第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。
*   第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。
```
### AMD和CMD的区别
```
1.  第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。
2.  第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。
```
### V8引擎的垃圾回收机制
```
v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。
​
新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。
​
新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：
​
（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。
​
（2）如果对象不存活，则释放对象的空间。
​
（3）最后将 From 空间和 To 空间角色进行交换。
​
新生代对象晋升到老生代有两个条件：
​
（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。
​
（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。
​
老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。
​
由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。
```