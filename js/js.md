### 1.const定义一个对象，能用另一个对象替换？
```
不能，const声明一个只读常量，一旦声明，常量的值就不能改变。
```
### 2.JS内存泄漏有哪些情况？
```
1. 循环引用：当两个或多个对象之间存在相互引用，并且没有被其他对象引用，就会发生循环引用，从而导致内存泄漏。这种情况可以通过在对象之间断开引用来避免。
2. 定时器未清除：在JavaScript中使用setInterval和setTimeout函数时，必须确保在不需要他们时清除这些定时器。
3. DOM元素未正确删除：在使用JS操作DOM元素时，必须确保在不需要它们时正确删除它们。
4. 全部变量未清除：在JS中，如果定义了全局变量，它们将一直存在于内存中，直到页面关闭。如果不需要全局变量，请确保在使用后将其删除或赋值为null。
5. 闭包未正确使用：在JS中，闭包可以让函数访问其定义时的作用域，但如果未正确使用闭包，也可能导致内存泄漏。在使用闭包时，请确保只保留必要的引用，并在不需要时删除它们。
6. 事件未及时解绑：在JS中，如果注册了事件监听器却没有及时解绑，就会导致内存泄漏。例如当一个元素被删除时，它仍然保留对事件监听器的引用，如果没有解绑，事件监听器将无法被垃圾回收。
```
### 3.闭包为什么会造成内存泄漏？
```
闭包：1.父函数嵌套子函数，子函数访问父函数的局部变量。2.通过return返回这个子函数，暴露到全部作用域中，子函数形成了闭包。3.通过闭包，父函数的局部变量没有被销毁，可通过闭包去调用，但同时，这个局部变量也不会被全局变量污染。
闭包的作用与优缺点：
作用：
1）保护：保护函数的私有变量不被外部干扰。
2）保存：把一些函数内的值保存下来，闭包可以实现方法与属性的私有化。

优点：
1）延长局部变量的生命周期。
2）避免全局污染。
3）函数外部能访问函数内容的变量。

缺点：
1）闭包会携带包含其他的函数作用域，因此会比其他函数占用更多的内存。
2）不正当的使用可能会造成内存泄漏。

1. 难以控制：闭包能够访问外部函数的作用域，这意味着外部函数的变量可能会被闭包内部修改。如果这些变量不被正确处理，可能会导致内存泄漏。
2. 占用内存：闭包内部访问的变量通常不会被回收机制释放，因为它们被保存在了闭包的执行环境中。全局变量由于随时可以被任何程序在任何地方读写，所以回收机制很难统计何时需要释放全局变量所占用的内存，也就导致全局变量一般在全局执行环境被销毁时才会释放。闭包由于能够访问外部函数的变量，如果这些变量是引用类型（如Array、Object、Function），它们的值存储在堆内存中，而闭包的执行环境（栈内存）会引用这些变量，导致它们不会被回收机制释放，从而形成内存泄漏。
闭包本身不会直接造成内存泄漏，但如果在代码中过度使用闭包，并且没有正确处理闭包内部访问的变量，就可能存在内存泄漏的风险。
```
### 4.JS的数据类型
```
简单数据类型：string、number、boolean、null、undefined、symbol、bigInt
复杂数据类型：object(function、array。。。)
```
### 5.typeof和instanceof的区别
```
typeof能识别简单数据类型及函数，对于array和object无法区分，其中null 的检测值也为 object
instanceof用于检测构造函数的prototype是否出现在某个实例的原型链上，可以区分引用数据类型
```
### 6.实现一个类似关键字new功能的函数
```javascript
// new关键字：先创建一个空对象，将对象的__proto__指向构造函数的原型对象，然后将构造函数的this指向这个空对象，并执行构造函数的逻辑，根据构造函数的执行逻辑，返回初始创建的对象或构造函数的显式返回值。
function newFunc(...args) {
  const constructor = args.shift()
  const newInstance = Object.create(constructor.prototype)
  const res = constructor.apply(newInstance, args)
  return (typeof res === 'object' || typeof res === 'function') && res !== null ? res : newInstance
}
```
### 7.继承
```
1.原型链继承
  优点：
      1.父类方法可以复用
  缺点：
      1.父类的所有引用属性（info）会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响
      2.子类型实例不能给父类型构造函数传参

2.借用构造函数继承
  优点:
      1.可以在子类构造函数中向父类传参数
      2.父类的引用属性不会被共享
  缺点：
      1.子类不能访问父类原型上定义的方法（即不能访问Parent.prototype上定义的方法），因此所有方法属性都写在构造函数中，每次创建实例都会初始化

3.组合继承
  优点：
      1.父类的方法可以复用
      2.可以在Child构造函数中向Parent构造函数中传参
      3.父类构造函数中的引用属性不会被共享

4.原型式继承
  优点：
      1.父类方法可复用
  缺点：
      1.父类的引用会被所有子类所共享
      2.子类实例不能向父类传参

5.寄生式继承
  优点：写法简单，不需要单独创建构造函数。
  缺点：通过寄生式继承给对象添加函数会导致函数难以重用。使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率;这一点与构造函数模式类似.

6.寄生式组合继承
  优点：
      1.只调用一次父类构造函数
      2.Child可以向Parent传参
      3.父类方法可以复用
      4.父类的引用属性不会被共享

7.ES6类继承
```
